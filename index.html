<html>
<head>
<style>
html, body {
  background: white;
  color: black;
  margin: 0;
  padding: 0;
}
#topbar {
  border-bottom: solid black 1px;
  display: flex;
  flex-direction: row;
  padding: 0.5em 0;
}
#topbar > * {
  margin-left: 0.5em;
}
canvas {
  border: solid white 1px;
}
</style>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
let svg = {
  svg: (width, height, attrs={}) => {
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    rtn.setAttribute("viewBox", "0 0 " + width + " " + height);
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  },
  g: (attrs={}) => {
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "g");
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  },

  // Shapes
  rect: (x, y, width, height, attrs={}) => {
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rtn.setAttribute("x", x);
    rtn.setAttribute("y", y);
    rtn.setAttribute("width", width);
    rtn.setAttribute("height", height);
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  },
  circle: (cx, cy, r, attrs={}) => {
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    rtn.setAttribute("cx", cx);
    rtn.setAttribute("cy", cy);
    rtn.setAttribute("r", r);
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  },
  ellipse: (cx, cy, rx, ry, attrs={}) => {
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
    rtn.setAttribute("cx", cx);
    rtn.setAttribute("cy", cy);
    rtn.setAttribute("rx", rx);
    rtn.setAttribute("ry", ry);
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  },
  polygon: (xs, ys, attrs={}) => {
    if (xs.length != ys.length) return undefined;
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    let pointString = "";
    for (let i = 0; i < xs.length; ++i) {
      if (i != 0) pointString += " ";
      pointString += xs[i] + "," + ys[i];
    }
    rtn.setAttribute("points", pointString);
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  },

  // Paths
  line: (x1, y1, x2, y2, attrs={}) => {
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "line");
    rtn.setAttribute("x1", x1);
    rtn.setAttribute("y1", y1);
    rtn.setAttribute("x2", x2);
    rtn.setAttribute("y2", y2);
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  },
  path: (attrs={}) => {
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "path");
    let _append = (pathElement, moveType, newValues=undefined) => {
      let value = pathElement.getAttribute("d");
      if (value) {
        value += " "
      } else {
        value = "";
      }
      value += moveType;
      if (newValues) {
        value += " ";
        value += newValues.join(",");
      }
      rtn.setAttribute("d", value);
    }
    rtn.moveTo = (x, y) => {                                                _append(rtn, "M", [x, y]);                                                 };
    rtn.lineTo = (x, y) => {                                                _append(rtn, "L", [x, y]);                                                 };
    rtn.curveTo = (x1, y1, x2, y2, x3, y4) => {                             _append(rtn, "L", [x1, y1, x2, y2, x3, y3]);                               };
    rtn.smoothCurveTo = (x1, y1, x2, y2) => {                               _append(rtn, "S", [x1, y1, x2, y2]);                                       };
    rtn.quadraticTo = (x1, y1, x2, y2) => {                                 _append(rtn, "Q", [x1, y1, x2, y2]);                                       };
    rtn.smoothQuadraticTo = (x, y) => {                                     _append(rtn, "T", [x, y]);                                                 };
    rtn.arcTo = (rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) => { _append(rtn, "A", [rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y]); };
    rtn.close = () => {                                                     _append(rtn, "Z");                                                         };
    rtn.setAttribute("fill", "none");
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  },
  polyline: (xs, ys, attrs={}) => {
    if (xs.length != ys.length) return undefined;
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
    let pointString = "";
    for (let i = 0; i < xs.length; ++i) {
      if (i != 0) pointString += " ";
      pointString += xs[i] + "," + ys[i];
    }
    rtn.setAttribute("points", pointString);
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  },

  // Other
  linearGradient: (attrs={}) => {
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
    rtn.addStop = (offset, color, opacity=1, attrs={}) => {
      let rtn = document.createElementNS("http://www.w3.org/2000/svg", "stop");
      rtn.setAttribute("offset", offset);
      rtn.setAttribute("color", color);
      rtn.setAttribute("opacity", opacity);
      for (key in attrs) rtn.setAttribute(key, attrs[key]);
      return rtn;
    };
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  },
  radientGradient: (attrs={}) => {
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "radientGradient");
    rtn.addStop = (offset, color, opacity=1, attrs={}) => {
      let rtn = document.createElementNS("http://www.w3.org/2000/svg", "stop");
      rtn.setAttribute("offset", offset);
      rtn.setAttribute("color", color);
      rtn.setAttribute("opacity", opacity);
      for (key in attrs) rtn.setAttribute(key, attrs[key]);
      return rtn;
    };
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  },
  text: (str, x, y, attrs={}) => {
    // Useful Attributes:
    //   text-anchor = "start", "middle", "end"
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "text");
    rtn.setAttribute("x", x);
    rtn.setAttribute("y", y);
    rtn.innerHTML = str;
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  },
  image: (src, x, y, attrs={}) => {
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "image");
    rtn.setAttributeNS('http://www.w3.org/1999/xlink','href', src);
    rtn.setAttribute("x", x);
    rtn.setAttribute("y", y);
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  }
};

function range(low, high) {
  let r = new Float64Array(high - low);
  for (let i = low; i < high; ++i) {
    r[i] = i;
  }
  return r;
}

function percentile(A, p) {
  // TODO: use O(n) selction algorithm
  A = new Float64Array(A);
  A.sort();
  return A[Math.round((A.length - 1) * p)];
}

function smooth(A, radius) {
  if (radius === 0) {
    return A;
  }
  let S = new Float64Array(A.length + 1);
  S[0] = 0;
  for (let i = 0; i < A.length; ++i) {
    S[i + 1] = S[i] + A[i];
  }

  let R = new Float64Array(A.length);
  for (let i = 0; i < A.length; ++i) {
    let a = Math.max(0, i - radius);
    let b = Math.min(A.length - 1, i + radius + 1);
    R[i] = (S[b] - S[a]) / (b - a);
  }

  return R;
}

function get_metrics(dirName) {
  return window.fetch('./api/get_runs?dir=' + encodeURIComponent(dirName))
  .then(r => r.json())
  .then(runNames => {
    let runsToShow = runsInput.value.replace(/\s/g, "").split(',');
    let runPromises = [];
    for (let runName of runNames) {
      if (!runsToShow.includes(runName)) {
        continue;
      }
      let url = './api/get_families?dir=' + encodeURIComponent(dirName);
      url += '&run=' + encodeURIComponent(runName);
      runPromises.push(
        window.fetch(url)
        .then(r => r.json())
        .then(metricNames => {
          let metricPromises = [];
          for (let metricName of metricNames) {
            let url = './api/get_data?dir=' + encodeURIComponent(dirName);
            url += '&run=' + encodeURIComponent(runName);
            url += '&metric=' + encodeURIComponent(metricName);
            metricPromises.push(window.fetch(url).then(r => r.json()));
          }
          return Promise.all(metricPromises);
        })
      );
    }
    return Promise.all(runPromises);
  }).then(runs => {
    let metrics = {};
    for (let run of runs) {
      for (let metric of run) {
        if (!(metric["metricName"] in metrics)) {
          metrics[metric["metricName"]] = [];
        }
        metrics[metric["metricName"]].push(metric)
      }
    }
    return metrics;
  })
}

function render() {
  get_metrics(dirInput.value).then(metrics => {
    graphsDiv.innerHTML = "";
    for (let metricName in metrics) {
      let chartContainer = document.createElement('DIV');
      chartContainer.style.width = '100%';
      chartContainer.style.height = '40vw';
      chartContainer.style.marginBottom = '5em';
      let cvs = document.createElement('CANVAS');
      chartContainer.appendChild(cvs);
      graphsDiv.appendChild(chartContainer);

      let data = {
        "datasets": []
      };
      const colors = [
        'rgb(  0,  89, 144)',
        'rgb(220,  95,   0)',
        'rgb(  0, 128,  24)',
        'rgb(180,   0,   1)',
        'rgb(116,  73, 153)',
        'rgb(108,  56,  47)',
        'rgb(192,  88, 158)',
      ];

      let runNames = Object.keys(metrics[metricName]);
      for (let i in runNames) {
        let runName = runNames[i];
        let run = metrics[metricName][runName];
        let X = run["x"];
        let Y = run["y"];

        Y = smooth(Y, parseFloat(smoothInput.value));
        if (highClipInput.value < 100) {
          let p = percentile(Y, highClipInput.value / 100);
          Y = Y.map(y => Math.min(y, p));
        }

        let color = colors[i % colors.length];
        data["datasets"].push({
          "type": "line",
          "label": run.metricName + ":" + run.runName,
          "data": Y,
          "borderColor": color,
          "backgroundColor": color,
          "pointRadius": 0,
        });
      }
      data["labels"] = metrics[metricName][0]["x"];
      let config = {
        "data": data,
        "options": {
          "animation": {
            "duration": 0
          }
        },
      };
      let chart = new Chart(cvs, config);
    }
  })
}

window.addEventListener('load', () => {
  dirInput.value = "logs";
  runsInput.value = "a,b";
  smoothInput.addEventListener('input', () => {
    smoothInput.value = Math.max(0, Math.min(500, smoothInput.value));
  });
  highClipInput.addEventListener('input', () => {
    highClipInput.value = Math.max(0, Math.min(100, highClipInput.value));
  });
  refreshButton.addEventListener('click', render);
  render();
})
</script>
</head>
<body>
<div id="topbar">
  <input id="dirInput" type="text">

  <div style="border-left: solid black 1px"></div>

  <input id="runsInput" type="text">

  <div style="border-left: solid black 1px"></div>

  <div>smooth</div>
  <input id="smoothInput" type="number" value="1" style="width:4em;">

  <div style="border-left: solid black 1px"></div>

  <div>clip</div>
  <input id="highClipInput" type="number" value="100" style="width:4em;">

  <div style="border-left: solid black 1px"></div>

  <button id="refreshButton">Refresh</button>

</div>
<div id="graphsDiv"></div>
</body>
</html>