<html>
<head>
<style>
html, body {
  background: white;
  color: black;
  margin: 0;
  padding: 0;
}
#topbar {
  border-bottom: solid black 1px;
  display: flex;
  flex-direction: row;
  padding: 0.5em 0;
}
#topbar > * {
  margin-left: 0.5em;
}
canvas {
  border: solid white 1px;
}
</style>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
let svg = {
  svg: (width, height, attrs={}) => {
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    rtn.setAttribute("viewBox", "0 0 " + width + " " + height);
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  },
  g: (attrs={}) => {
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "g");
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  },

  // Shapes
  rect: (x, y, width, height, attrs={}) => {
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rtn.setAttribute("x", x);
    rtn.setAttribute("y", y);
    rtn.setAttribute("width", width);
    rtn.setAttribute("height", height);
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  },
  circle: (cx, cy, r, attrs={}) => {
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    rtn.setAttribute("cx", cx);
    rtn.setAttribute("cy", cy);
    rtn.setAttribute("r", r);
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  },
  ellipse: (cx, cy, rx, ry, attrs={}) => {
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
    rtn.setAttribute("cx", cx);
    rtn.setAttribute("cy", cy);
    rtn.setAttribute("rx", rx);
    rtn.setAttribute("ry", ry);
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  },
  polygon: (xs, ys, attrs={}) => {
    if (xs.length != ys.length) return undefined;
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    let pointString = "";
    for (let i = 0; i < xs.length; ++i) {
      if (i != 0) pointString += " ";
      pointString += xs[i] + "," + ys[i];
    }
    rtn.setAttribute("points", pointString);
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  },

  // Paths
  line: (x1, y1, x2, y2, attrs={}) => {
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "line");
    rtn.setAttribute("x1", x1);
    rtn.setAttribute("y1", y1);
    rtn.setAttribute("x2", x2);
    rtn.setAttribute("y2", y2);
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  },
  path: (attrs={}) => {
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "path");
    let _append = (pathElement, moveType, newValues=undefined) => {
      let value = pathElement.getAttribute("d");
      if (value) {
        value += " "
      } else {
        value = "";
      }
      value += moveType;
      if (newValues) {
        value += " ";
        value += newValues.join(",");
      }
      rtn.setAttribute("d", value);
    }
    rtn.moveTo = (x, y) => {                                                _append(rtn, "M", [x, y]);                                                 };
    rtn.lineTo = (x, y) => {                                                _append(rtn, "L", [x, y]);                                                 };
    rtn.curveTo = (x1, y1, x2, y2, x3, y4) => {                             _append(rtn, "L", [x1, y1, x2, y2, x3, y3]);                               };
    rtn.smoothCurveTo = (x1, y1, x2, y2) => {                               _append(rtn, "S", [x1, y1, x2, y2]);                                       };
    rtn.quadraticTo = (x1, y1, x2, y2) => {                                 _append(rtn, "Q", [x1, y1, x2, y2]);                                       };
    rtn.smoothQuadraticTo = (x, y) => {                                     _append(rtn, "T", [x, y]);                                                 };
    rtn.arcTo = (rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) => { _append(rtn, "A", [rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y]); };
    rtn.close = () => {                                                     _append(rtn, "Z");                                                         };
    rtn.setAttribute("fill", "none");
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  },
  polyline: (xs, ys, attrs={}) => {
    if (xs.length != ys.length) return undefined;
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
    let pointString = "";
    for (let i = 0; i < xs.length; ++i) {
      if (i != 0) pointString += " ";
      pointString += xs[i] + "," + ys[i];
    }
    rtn.setAttribute("points", pointString);
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  },

  // Other
  linearGradient: (attrs={}) => {
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
    rtn.addStop = (offset, color, opacity=1, attrs={}) => {
      let rtn = document.createElementNS("http://www.w3.org/2000/svg", "stop");
      rtn.setAttribute("offset", offset);
      rtn.setAttribute("color", color);
      rtn.setAttribute("opacity", opacity);
      for (key in attrs) rtn.setAttribute(key, attrs[key]);
      return rtn;
    };
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  },
  radientGradient: (attrs={}) => {
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "radientGradient");
    rtn.addStop = (offset, color, opacity=1, attrs={}) => {
      let rtn = document.createElementNS("http://www.w3.org/2000/svg", "stop");
      rtn.setAttribute("offset", offset);
      rtn.setAttribute("color", color);
      rtn.setAttribute("opacity", opacity);
      for (key in attrs) rtn.setAttribute(key, attrs[key]);
      return rtn;
    };
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  },
  text: (str, x, y, attrs={}) => {
    // Useful Attributes:
    //   text-anchor = "start", "middle", "end"
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "text");
    rtn.setAttribute("x", x);
    rtn.setAttribute("y", y);
    rtn.innerHTML = str;
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  },
  image: (src, x, y, attrs={}) => {
    let rtn = document.createElementNS("http://www.w3.org/2000/svg", "image");
    rtn.setAttributeNS('http://www.w3.org/1999/xlink','href', src);
    rtn.setAttribute("x", x);
    rtn.setAttribute("y", y);
    for (key in attrs) rtn.setAttribute(key, attrs[key]);
    return rtn;
  }
};

function range(low, high) {
  let r = new Float64Array(high - low);
  for (let i = low; i < high; ++i) {
    r[i] = i;
  }
  return r;
}

function smooth(A, radius) {
  let S = new Float64Array(A.length);
  S[0] = A[0];
  for (let i = 1; i < A.length; ++i) {
    S[i] = S[i - 1] + A[i];
  }

  let R = new Float64Array(A.length);
  for (let i = 0; i < A.length; ++i) {
    let a = Math.max(0, i - radius - 1);
    let b = Math.min(A.length - 1, i + radius);
    R[i] = (S[b] - S[a]) / (b - a);
  }

  return R;
}

function dir_changed() {
  let dirName = dirInput.value;
  window.fetch('./api/get_families?dir=' + dirName).then(r => r.json()).then(r => {
    document.getElementById("dirInput").style.backgroundColor = '';
    graphsDiv.innerHTML = '';
    for (let metricName of r) {
      let chartContainer = document.createElement('DIV');
      chartContainer.style.width = '100%';
      chartContainer.style.height = '50vw';
      let cvs = document.createElement('CANVAS');
      chartContainer.appendChild(cvs);
      graphsDiv.appendChild(chartContainer);

      window.fetch('./api/get_data?dir=' + dirName + "&metric=" + metricName).then(r => r.json()).then(r => {
        let X = r["x"];
        let Ys = r["ys"];
        let data = {
          "labels": X,
          "datasets": []
        };
        const colors = [
          'rgb(  0,  89, 144)',
          'rgb(220,  95,   0)',
          'rgb(  0, 128,  24)',
          'rgb(180,   0,   1)',
          'rgb(116,  73, 153)',
          'rgb(108,  56,  47)',
          'rgb(192,  88, 158)',
        ]
        const D = Ys[0].length;
        for (let i = 0; i < D; ++i) {
          let Y = Ys.map(a => a[i]);
          let name = (D == 1 ? metricName : metricName) + ` (${i})`;
          let color = colors[i % colors.length];
          // data["datasets"].push({
          //   "type": "scatter",
          //   "label": name,
          //   "backgroundColor": color,
          //   "borderColor": color,
          //   "data": Y,
          // });
          data["datasets"].push({
            "type": "line",
            "label": name + " smoothed",
            "data": smooth(Y, parseFloat(smoothInput.value)),
            "borderColor": color,
            "backgroundColor": color,
            "pointRadius": 0,
          });
        }
        let config = {
          "data": data,
          "options": {
            "animation": {
              "duration": 0
            }
          },
        };
        let chart = new Chart(cvs, config);
      });
    }
  }).catch(err => {
    document.getElementById("dirInput").style.backgroundColor = 'red';
    document.getElementById("graphsDiv").innerHTML = '';
  });
}
window.addEventListener('load', () => {
  smoothInput.addEventListener('input', () => {
    if (smoothInput.value < 0) {
      smoothInput.value = 0;
    }
    if (smoothInput.value > 200) {
      smoothInput.value = 200;
    }
    dir_changed();
  });
  dirInput.value = 'a'
  dirInput.addEventListener('input', dir_changed);
  refreshButton.addEventListener('click', dir_changed);
  dir_changed();
})
</script>
</head>
<body>
<div id="topbar">
  <input id="dirInput" type="text">
  <input id="smoothInput" type="number" value="1" style="width:4em;">
  <button id="refreshButton">R</button>
</div>
<div id="graphsDiv"></div>
</body>
</html>